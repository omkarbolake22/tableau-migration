pipeline {
  agent any
  options { timestamps() }

  environment {
    AWS_REGION = 'us-east-1'
    WORK_ROOT  = "${env.WORKSPACE}"            // base dir we can write to
    CONDA_DIR  = "${env.WORKSPACE}/miniconda"  // user-space Python
    LOCAL_BIN  = "${env.WORKSPACE}/.local/bin" // user-space bin for aws
    PATH       = "${env.LOCAL_BIN}:${env.CONDA_DIR}/bin:${env.PATH}"
  }

  stages {
    stage('Checkout') { steps { checkout scm } }

    stage('Setup Python (user-space Miniconda)') {
      steps {
        sh '''
          set -eu

          # Install Miniconda silently into ${CONDA_DIR} if not present
          if [ ! -x "${CONDA_DIR}/bin/python" ]; then
            mkdir -p "${WORK_ROOT}/_tmp"
            cd "${WORK_ROOT}/_tmp"
            curl -fsSL https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh -o miniconda.sh
            sh miniconda.sh -b -p "${CONDA_DIR}"
            rm -f miniconda.sh
          fi

          # Verify python is available
          "${CONDA_DIR}/bin/python" --version
          "${CONDA_DIR}/bin/pip" --version

          # Optional: ensure pip is up to date
          "${CONDA_DIR}/bin/python" -m pip install --upgrade pip
        '''
      }
    }

    stage('Setup AWS CLI v2 (user-space)') {
      steps {
        sh '''
          set -eu
          mkdir -p "${LOCAL_BIN}"

          if ! command -v aws >/dev/null 2>&1; then
            echo "Installing AWS CLI v2 into workspace..."
            mkdir -p "${WORK_ROOT}/_tmp"
            cd "${WORK_ROOT}/_tmp"
            curl -fsSL "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o awscliv2.zip
            unzip -q -o awscliv2.zip
            ./aws/install -i "${WORK_ROOT}/.aws-cli" -b "${LOCAL_BIN}"
            rm -rf aws awscliv2.zip
          fi

          aws --version
        '''
      }
    }

    stage('Run All JSONs with AWS Credentials') {
  steps {
    sh(label: 'Revealv2 USPROD - Deployment', script: '''
      set -eu

      # Sanity checks
      command -v aws >/dev/null
      "${CONDA_DIR}/bin/python" --version
      "${CONDA_DIR}/bin/pip" --version

      # Assume role
      assume_role() {
        ROLE_ARN="$1"
        SESSION_NAME="$2"
        creds=$(aws sts assume-role \
          --role-arn "$ROLE_ARN" \
          --role-session-name "$SESSION_NAME" \
          --query "Credentials.[AccessKeyId,SecretAccessKey,SessionToken]" \
          --output text)
        AWS_ACCESS_KEY_ID=$(echo "$creds" | awk '{print $1}')
        AWS_SECRET_ACCESS_KEY=$(echo "$creds" | awk '{print $2}')
        AWS_SESSION_TOKEN=$(echo "$creds" | awk '{print $3}')
        export AWS_ACCESS_KEY_ID AWS_SECRET_ACCESS_KEY AWS_SESSION_TOKEN
      }
      assume_role "arn:aws:iam::889340682220:role/revealv2-tableau-usprod-deployment-role" "USPROD-Revealv2-Tableau-Jenkins-DeployRole"

      echo "Installing Python deps..."
      if [ -f requirements.txt ]; then
        "${CONDA_DIR}/bin/pip" install --no-cache-dir -r requirements.txt
      else
        # minimal deps for your script
        "${CONDA_DIR}/bin/pip" install --no-cache-dir boto3
      fi

      echo "Running deploy script..."
      # Run and capture logs
      "${CONDA_DIR}/bin/python" run_all_json_in_folder.py > output.log 2>&1 || true

      # Show last lines for visibility
      tail -n 80 output.log || true

      # Fail if python exit was non-zero OR log indicates failure
      # (adjust this grep to match your script's failure string)
      if grep -q "ModuleNotFoundError" output.log || grep -q "Failed on:" output.log; then
        echo "Detected failures in output.log"
        exit 1
      fi

      echo "Python script completed successfully"
    ''')
  }
}
  }

  post {
    always  { echo 'Pipeline finished.' }
    failure { echo 'Deployment failed!' }
  }
}
